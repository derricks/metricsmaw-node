/** Include module for metricsmaw */

var net = require('net')
  , events = require('events')
  , util = require("./mmutil")
;

var SEND_METRIC_EVENT = 'sendMetric';
var COUNTER_TYPE = 'counter';
var GAUGE_TYPE = 'gauge';
var METER_TYPE = 'meter_minute';
var SMALL_INT_SIZE = 255;

var initted = false;

var queue = null;
var listener = null;
var metricsRelay = null;

var metricsHost = null;
var metricsPort = null;

exports.init = function(host,port) {
    // singleton object, so just return on subsequent init
    // todo: throw an error?
    if (initted) return;
    
    metricsHost = host;
    metricsPort = port;
    
    queue = new MetricsQueue();
    listener = new MetricsQueueListener(queue,host,port);
    initted = true;
};

exports.incrementCounter = function(name,amount,callback) {
    sendToQueue(name,COUNTER_TYPE,amount,callback);    
};

exports.decrementCounter = function(name,amount,callback) {
    sendToQueue(name,COUNTER_TYPE,-amount,callback);
};

exports.setGauge = function(name,value,callback) {
    sendToQueue(name,GAUGE_TYPE,value,callback);
};

/** Adds a value to a rate meter. */
exports.markMeter = function(name,amount,callback) {
    sendToQueue(name,METER_TYPE,amount,callback);
};

/** Retrieve the list of metric names currently active in the server.
 *  Callback = function(err,results)
 */
exports.getAllMetricNames = function(callback) {
    
   requestResponseJavascript(util.tuple("all_metric_names"),function(err,data) {
        if (err) callback(err,null);
        else callback(null,data);
   });
};

/** Get the full details for a given metric. Metric name is the name you want to recover (without the machine name). callback is function(err,result) */
exports.getMetricDetails = function(metricName,callback) {
    requestResponseJavascript(util.tuple("get_metric_details",metricName),function(err,response) {
        if (err) callback(err,null);
        else callback(null,response); 
    });
};

/** Utility method for taking some javascript bits, opening a socket, sending the (converted) JavaScript bits over the wire, and then waiting
    for a response and converting that from erlang to JavaScript.
    Last argument is a function that takes err and response.
    */
requestResponseJavascript = function() {
    var callback = arguments[arguments.length - 1];
    var jsArgs = Array.prototype.slice.call(arguments, 0, arguments.length - 1);
    
    // handles socket connect by sending data and then calling back when response has arrived
    var handleConnect = function(err,socket) {
        if (err) callback(err,null);
        
        socket.on("data",function(data) {
            callback(null,util.javascriptFromErlangBinary(data));
            socket.end();
        });
        
        // we've connected, so create the query
        var buf = util.erlangBinaryFromJavascript.apply(util,jsArgs);
        socket.write(buf,'utf8',
                     function(err) {if(err) callback(err,null);});
        
    }
    connectSocket(metricsHost,metricsPort,handleConnect);
};

sendToQueue = function(name,type,data,callback) {
    var errorString = "Metrics unavailable. Was init(host,port) called?";
    if (!queue && callback) {callback(new Error(errorString));return;}
    if (!queue && !callback) {console.log(errorString);return;}
    
    queue.sendMetric(name,type,data,callback);
}

function MetricsQueue(){};

/** Opens the socket and sets it up. callback is function(err,socket) */
function connectSocket(host,port,callback) {
    var socket = new net.Socket();
    
    var connectHandler = function() {socket.setKeepAlive(true);callback(null,socket);}
    socket.on("connect",connectHandler);

    socket.connect(port,host);
}



MetricsQueue.prototype = new events.EventEmitter();



/** Takes in a particular piece of data to send to the system. Callback gets an error, or null if there wasn't one.*/
MetricsQueue.prototype.sendMetric = function(name,type,data,callback) {
    if (!initted) {
        var error = "Call init before calling sendMetric";
        if (callback) callback(new Error(error));
        else console.log("Call init before calling sendMetric")
        return;
    }
    
    if (typeof data != 'number') {
        var error = "Data argument must be a number";
        if (callback) callback (new Error(error));
        else console.log(error);
        return;
    }
    
    this.emit(SEND_METRIC_EVENT,name,type,data);  
    if(callback) callback(null);
};


/** MetricsQueueListener acts as a recipient for queue messages. Clients of the library push into the queue, which
    in turn generates events. The listener responds to that event by sending up to the server. */
function MetricsQueueListener(metricsQueue,metricsHost,metricsPort) {
   this.queue = metricsQueue;
   this.metricsHost = metricsHost;
   this.metricsPort = metricsPort;
   this.socket = null;
   
   var self = this;
   this.sendBinaryToServer = function(binary) {
       if (!this.socket) {
           connectSocket(metricsHost,metricsPort,function(err,socket) {
              self.socket = socket;
              self.sendBinaryToServer(binary);       
           });
       } else {
           this.socket.write(binary,'utf8',function(err) {});
       }
   };
   
   this.handleMetric = function(name,type,data) {
        listener.sendBinaryToServer(util.erlangBinaryFromJavascript(util.tuple("add",name,type,data)));
   }; 
   
   
   /** The actual subscription to queue events */
   this.queue.on(SEND_METRIC_EVENT,this.handleMetric); 
};