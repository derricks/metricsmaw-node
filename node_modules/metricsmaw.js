/** Include module for metricsmaw */

var net = require('net')
  , events = require('events')
;

var SEND_METRIC_EVENT = 'sendMetric';
var COUNTER_TYPE = 'counter';
var GAUGE_TYPE = 'gauge';
var METER_TYPE = 'meter_minute';
var SMALL_INT_SIZE = 255;

var initted = false;

var queue = null;
var listener = null;

exports.init = function(host,port) {
    // singleton object, so just return on subsequent init
    // todo: throw an error?
    if (initted) return;
    
    queue = new MetricsQueue();
    listener = new MetricsQueueListener(queue,host,port);
    initted = true;
};

exports.incrementCounter = function(name,amount,callback) {
    sendToQueue(name,COUNTER_TYPE,amount,callback);    
}

exports.decrementCounter = function(name,amount,callback) {
    sendToQueue(name,COUNTER_TYPE,-amount,callback);
}

exports.setGauge = function(name,value,callback) {
    sendToQueue(name,GAUGE_TYPE,value,callback);
}

exports.markMeter = function(name,amount,callback) {
    sendToQueue(name,METER_TYPE,amount,callback);
}


sendToQueue = function(name,type,data,callback) {
    var errorString = "Metrics unavailable. Was init(host,port) called?";
    if (!queue && callback) {callback(new Error(errorString));return;}
    if (!queue && !callback) {console.log(errorString);return;}
    
    queue.sendMetric(name,type,data,callback);
}

function MetricsQueue(){};

function connectSocket(host,port) {
    
    socket = new net.Socket();
    socket.connect(port,host);
    socket.setKeepAlive(true);
    return socket;
}

MetricsQueue.prototype = new events.EventEmitter();



/** Takes in a particular piece of data to send to the system. Callback gets an error.*/
MetricsQueue.prototype.sendMetric = function(name,type,data,callback) {
    if (!initted) {
        var error = "Call init before calling sendMetric";
        if (callback) callback(new Error(error));
        else console.log("Call init before calling sendMetric")
        return;
    }
    
    if (typeof data != 'number') {
        var error = "Data argument must be a number";
        if (callback) callback (new Error(error));
        else console.log(error);
        return;
    }
    
    this.emit(SEND_METRIC_EVENT,name,type,data);  
    if(callback) callback(null);
};



function MetricsQueueListener(metricsQueue,metricsHost,metricsPort) {
   this.queue = metricsQueue;
   this.metricsHost = metricsHost;
   this.metricsPort = metricsPort;
   this.socket = null;
   
   // erlang binary format documented here: http://www.erlang.org/doc/apps/erts/erl_ext_dist.html
   this.convertToErlangBinary = function(name,type,data) {
       
       var isInt = function(n) {
           return n % 1 == 0;
       };

       var isFloat = function(n) {
           return !isInt(n);
       };
       
       var addAtom = "add";
       
       // create the erlang binary. 

       // create a buffer of the correct length
       // length = 
       //     start byte + 
       //     small tuple byte +
       //     atom byte +
       //     name.length +
       //     atom byte +
       //     type.length + 
       //     numeric type (small or large) +
       //     number -> bytes

       // figure out the length

       var bufLength = 0;

       // some convenience flags to prevent expensive recalculations
       var isSmallInt = false;
       var isBigInt = false;
       var isFloat = false;
       var floatString = "";

       // if data is a float, calculate the float string and its length
       // if it's an int, determine its length
       bufLength = bufLength + 1; // for the header of the data field
       if (isInt(data)) {
           if (data > SMALL_INT_SIZE || data < 0) {
               isBigInt = true;
               bufLength = bufLength + 4; // to hold a 4-byte int
           } else {
               isSmallInt = true;
               bufLength = bufLength + 1; // to hold the small value
           }
       } else if (isFloat(data)) {
           isFloat = true;
           floatString = '' + data;
           bufLength = bufLength + floatString.length;
       }
       
       // the type atom
       bufLength = bufLength + 3; // the header byte + the 2 bytes specifying the length of type
       bufLength = bufLength + type.length; // the length of the type field

       // the name atom
       bufLength = bufLength + 3; // header byte + 2 length bytes
       bufLength = bufLength + name.length; // the metric name
       
       // the add atom
       bufLength = bufLength + 3;
       bufLength = bufLength + addAtom.length;

       // now the tuple params
       bufLength = bufLength + 2; // the tuple header plus its arity

       // now create the actual buffer
       buf = new Buffer(bufLength + 1); // todo: why do we need an extra byte at the end? this suggests something is wrong with the math!!

       // and fill it in
       // basic start
       buf[0] = 131; // start of erlang term
       buf[1] = 104; // start of small tuple
          buf[2] = 4; // the arity of the tuple

       // the add atom
       buf[3] = 100; // indicate an atom
          buf.writeInt16BE(addAtom.length,4); // write the atom length into a big-endian 2-byte array
          buf.write(addAtom,6); // writes out the atom name      

       buf[9] = 100; // indicate an atom
          buf.writeInt16BE(name.length,10); // write the atom length into a big-endian 2-byte array
          buf.write(name,12); // writes out the atom name      

       var newOffset = 12 + name.length;
       
       buf[newOffset] = 100; // atom-type indicator
           buf.writeInt16BE(type.length,newOffset + 1);
           buf.write(type,newOffset + 3);

       newOffset = newOffset + 3 + type.length; // adjust forward

       if(isSmallInt) {
           buf[newOffset] = 97;
           buf[newOffset + 1] = data;
       } else if (isBigInt) {
           buf[newOffset] = 98;
           buf.writeInt32BE(data, buf[newOffset + 1]);
       } else if (isFloat) {
           buf[newOffset] = 99;
           buf.write('' + data,newOffset + 1);
       }
       return buf;
   };
   
   this.sendBinaryToServer = function(binary,callback) {
       if (!this.socket) {
           this.socket = connectSocket(metricsHost,metricsPort);
       }       

       this.socket.write(binary,'utf8',function(err) {});
   };
   
   this.handleMetric = function(name,type,data) {
         
        listener.sendBinaryToServer(listener.convertToErlangBinary(name,type,data)); 
   }; 
   
   
   this.queue.on(SEND_METRIC_EVENT,this.handleMetric); 
};