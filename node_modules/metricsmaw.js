/** Include module for metricsmaw */

var net = require('net')
  , events = require('events')
  , util = require("./util")
;

var SEND_METRIC_EVENT = 'sendMetric';
var COUNTER_TYPE = 'counter';
var GAUGE_TYPE = 'gauge';
var METER_TYPE = 'meter_minute';
var SMALL_INT_SIZE = 255;

var initted = false;

var queue = null;
var listener = null;
var metricsRelay = null;

exports.init = function(host,port) {
    // singleton object, so just return on subsequent init
    // todo: throw an error?
    if (initted) return;
    
    queue = new MetricsQueue();
    listener = new MetricsQueueListener(queue,host,port);
    initted = true;
};

exports.incrementCounter = function(name,amount,callback) {
    sendToQueue(name,COUNTER_TYPE,amount,callback);    
}

exports.decrementCounter = function(name,amount,callback) {
    sendToQueue(name,COUNTER_TYPE,-amount,callback);
}

exports.setGauge = function(name,value,callback) {
    sendToQueue(name,GAUGE_TYPE,value,callback);
}

/** Adds a value to a rate meter. */
exports.markMeter = function(name,amount,callback) {
    sendToQueue(name,METER_TYPE,amount,callback);
}


sendToQueue = function(name,type,data,callback) {
    var errorString = "Metrics unavailable. Was init(host,port) called?";
    if (!queue && callback) {callback(new Error(errorString));return;}
    if (!queue && !callback) {console.log(errorString);return;}
    
    queue.sendMetric(name,type,data,callback);
}

function MetricsQueue(){};

function connectSocket(host,port) {
    
    socket = new net.Socket();
    socket.connect(port,host);
    socket.setKeepAlive(true);
    return socket;
}


MetricsQueue.prototype = new events.EventEmitter();



/** Takes in a particular piece of data to send to the system. Callback gets an error, or null if there wasn't one.*/
MetricsQueue.prototype.sendMetric = function(name,type,data,callback) {
    if (!initted) {
        var error = "Call init before calling sendMetric";
        if (callback) callback(new Error(error));
        else console.log("Call init before calling sendMetric")
        return;
    }
    
    if (typeof data != 'number') {
        var error = "Data argument must be a number";
        if (callback) callback (new Error(error));
        else console.log(error);
        return;
    }
    
    this.emit(SEND_METRIC_EVENT,name,type,data);  
    if(callback) callback(null);
};


/** MetricsQueueListener acts as a recipient for queue messages. Clients of the library push into the queue, which
    in turn generates events. The listener responds to that event by sending up to the server. */
function MetricsQueueListener(metricsQueue,metricsHost,metricsPort) {
   this.queue = metricsQueue;
   this.metricsHost = metricsHost;
   this.metricsPort = metricsPort;
   this.socket = null;
   
   this.sendBinaryToServer = function(binary,callback) {
       if (!this.socket) {
           this.socket = connectSocket(metricsHost,metricsPort);
       }       

       this.socket.write(binary,'utf8',function(err) {});
   };
   
   this.handleMetric = function(name,type,data) {
        listener.sendBinaryToServer(util.erlangBinaryFromJavascript(util.tuple("add",name,type,data)));
   }; 
   
   
   /** The actual subscription to queue events */
   this.queue.on(SEND_METRIC_EVENT,this.handleMetric); 
};