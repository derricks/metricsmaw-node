/** Utility methods for metricsmaw. */
var util = 
    require('util')
    ;

var TERM_START = 131;
var ATOM_START = 100;
var SMALL_INT_START = 97;
var SMALL_INT_SIZE = 256;
var BIG_INT_START = 98;
var LIST_START = 108;
var NIL_EXT = 106;
var SMALL_TUPLE_START = 104;

/** Converts javascript-based arguments into erlang binary */
exports.erlangBinaryFromJavascript = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    
    var buf = new Buffer(erlangLengthFromJavascript(args));
    
    buf[0] = TERM_START; // the erlang "start of term" flag
    
    var offset = 1;
    encodeItemsIntoBuffer(buf,1,args);
    return buf;
}

/** Creates a tuple off the arguments */
exports.tuple = function() {return new Tuple(Array.prototype.slice.call(arguments, 0))};



// encode all the items into the buffer, starting at the offset. return the count of bytes written
encodeItemsIntoBuffer = function(buf,offset,items) {
    // in functional programming land, I'd implement this as an accumulator with sliced arrays
    // not sure if that's the best way to tackle this problem in v8
    
    console.log("list: %s",items);
    
    var localOffset = offset; // make a copy to prevent stomping on the value
    var totalBytesEncoded = 0;
    items.forEach(function(item) {
        var myBytesEncoded = encodeItemIntoBuffer(buf,localOffset,item);
        localOffset = localOffset + myBytesEncoded;
        totalBytesEncoded = totalBytesEncoded + myBytesEncoded;
    });
    return totalBytesEncoded;

}

// given a buffer object, an offset into that buffer, encode the item
// return the number of bytes written
encodeItemIntoBuffer = function(buf,offset,curTerm) {
    if (typeof item == null) {
        return 0;
    } else if (typeof curTerm === "string") {
        // write an atom: 100 + 2 bytes for byte length + string length
        buf[offset] = ATOM_START;
        buf.writeInt16BE(curTerm.length,offset+1);
        buf.write(curTerm,offset+3,curTerm.length);
        return 3 + curTerm.length;
    } else if (typeof curTerm === "number") {
        if (isInt(curTerm)) {
            if (curTerm < SMALL_INT_SIZE) { // max range for a small int
                buf[offset] = SMALL_INT_START;
                buf[offset+1] = curTerm;
                return 2;
            } else {
                buf[offset] = BIG_INT_START;
                buf.writeInt32BE(curTerm,offset+1);
                return 5;
            }
        }
    } else if (util.isArray(curTerm)) {
        // treat like a list
        buf[offset] = LIST_START;
        buf.writeInt32BE(curTerm.length,offset+1);
        var listBytesWritten = encodeItemsIntoBuffer(buf,offset+5,curTerm);
        buf[offset+5+listBytesWritten] = NIL_EXT;
        return 6 + listBytesWritten; // tag + length + nil length
    } else if (curTerm instanceof Tuple) {
        buf[offset] = SMALL_TUPLE_START;
        buf[offset+1] = curTerm.elems.length;
        var tupleBytesWritten = encodeItemsIntoBuffer(buf,offset+2,curTerm.elems);
        return 2 + tupleBytesWritten;
    }
}

/** A representation of a tuple class (which is a container for an array, but allows the code to distinguish them) */
function Tuple(elements) {
    this.elems = elements;
    
}

erlangLengthFromJavascript = function(items) {
    // we know an erlang buffer always starts with a particular byte
    var binaryLength = 1;
    
    items.forEach(function(curTerm) {
        // there will always be at least one byte indicating the  type of data
        binaryLength = binaryLength + 1;
        
        // determine the type of the object and then add accordingly
        if (typeof curTerm == null) {
            // easy; just skip
        } else if (typeof curTerm === "string") {
            // convert this to an atom
            binaryLength = binaryLength + 2 + curTerm.length; // atom = 2 bytes for length, rest for the atom characters themselves 
        } else if (typeof curTerm === "number") {
            // is it an int or a float?
            if (isInt(curTerm)) {
                // small int?
                if(curTerm < SMALL_INT_SIZE) {
                    binaryLength = binaryLength + 1; // 1 byte to hold number
                } else {
                    binaryLength = binaryLength + 4; // 4 bytes for large numbers
                }
                
            } else {
                // it's a float, which in erlang is a string representation of the float
                // todo support floats
            }
        } else if (util.isArray(curTerm)) {
            binaryLength = binaryLength + 6 + erlangLengthFromJavascript(curTerm); // + 4 for length of list
        } else if (curTerm instanceof Tuple) {
            binaryLength = binaryLength + 1 + erlangLengthFromJavascript(curTerm.elems); // + 1 for the arity of the tuple
        }
    });
    
    return binaryLength;
}

isInt = function(n) {
    return n % 1 == 0;
};

isFloat = function(n) {
    return !isInt(n);
};
