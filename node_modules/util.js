/** Utility methods for metricsmaw. */

/** Many of these deal with parsing and constructing erlang binary terms, which is documented here. 
    http://www.erlang.org/doc/apps/erts/erl_ext_dist.html
*/
var util = 
    require('util')
    ;

var TERM_START = 131;
var ATOM_START = 100;
var SMALL_INT_START = 97;
var SMALL_INT_SIZE = 256;
var BIG_INT_START = 98;
var LIST_START = 108;
var NIL_EXT = 106;
var SMALL_TUPLE_START = 104;
var FLOAT_START = 99;

/** Converts javascript-based arguments into erlang binary */
exports.erlangBinaryFromJavascript = function() {
    var args = Array.prototype.slice.call(arguments, 0);
    
    var buf = new Buffer(erlangLengthFromJavascript(args));
    
    buf[0] = TERM_START; // the erlang "start of term" flag
    
    var offset = 1;
    encodeItemsIntoBuffer(buf,1,args);
    return buf;
}

/** Creates a tuple off the arguments */
exports.tuple = function() {
    return new Tuple(Array.prototype.slice.call(arguments, 0))
};


/** Creates JSON from erlang binaries. Argument is a byte array from the server. */
exports.javascriptFromErlangBinary = function(binary) {
    return decodeItemFromBuffer(binary,1)[0]; // skip the first byte, which is just a "this is erlang" tag. and return the first item
}

// decodes a list or a tuple from the given binary. Returns an array where the first element is the data read and the second item is the number of bytes read.
decodeItemsFromBuffer = function(binary,offset) {
    var bytesRead = 0;
    // tuple or list?
    
    // common code for handling a collection of items, regardless of whether it's 
    // a tuple or a list
    // returns an array of the items read and the total bytes read
    var decodeCollectionItems = function(binary,offset,itemCount) {
        var bytesRead = 0;
        var returnItems = [];
        for(var itemIndex = 0; itemIndex < itemCount; itemIndex++) {
            item = decodeItemFromBuffer(binary,offset+bytesRead);
            returnItems.push(item[0]);
            bytesRead = bytesRead + item[1];
        }
        
        return [returnItems,bytesRead];
    }
    
    switch(binary[offset]) {
        case SMALL_TUPLE_START:
            // next byte is arity
            var arity = binary[offset+1];
            // increase bytes read
            bytesRead = bytesRead + 2; // for tuple byte and arity byte
            
            items = decodeCollectionItems(binary,offset+bytesRead,arity);
            return [new Tuple(items[0]),items[1] + 2];
            
        case LIST_START:
            var itemCount = binary.readInt32BE(offset+1);
            bytesRead = bytesRead + 5; // list byte + 4 bytes for length
            items = decodeCollectionItems(binary,offset+bytesRead,itemCount);
            return [items[0],items[1] + 6]; // 6 = initial byte, length of list, and the NIL_EXT byte
        default:
            return [null,bytesRead];
    }
}


// decode a single term from an erlang binary, passed as a byte array. 
// If it's a list or tuple, this will call down into decodeItemsFromBuffer to extract individual items
// returns an array where the first item is the data read and the second item is the number of bytes consumed
decodeItemFromBuffer = function(binary,offset) {
//    console.log("type %d",binary[offset]);
    
    switch(binary[offset]) {
        case SMALL_INT_START:
            return [binary[offset+1],2];
        case BIG_INT_START:
            // int is encoded as 4-byte bigendian
            return [binary.readInt32BE(offset+1),5];
        case SMALL_TUPLE_START:
        case LIST_START:
            // just pass this to decodeItems
            return decodeItemsFromBuffer(binary,offset);
        case ATOM_START:
            var atomSize = binary.readInt16BE(offset+1);
            var atomString = binary.toString("utf8",offset+3,offset+3+atomSize);
            return [atomString,atomString.length + 3]; // 3 = first byte to indicate atom, 2 bytes = string
        case FLOAT_START:
            // float is encoded as a string stretched across 31 bytes
            var floatString = binary.toString("utf8",offset+1,offset+1+31);
            return [parseFloat(floatString),32]; // leader byte + length
            
        default:
            return [null,0]; 
    }
}

// encode all the items into the buffer, starting at the offset. return the count of bytes written
encodeItemsIntoBuffer = function(buf,offset,items) {
    // in functional programming land, I'd implement this as an accumulator with sliced arrays
    // not sure if that's the best way to tackle this problem in v8
    
    var localOffset = offset; // make a copy to prevent stomping on the value
    var totalBytesEncoded = 0;
    items.forEach(function(item) {
        var myBytesEncoded = encodeItemIntoBuffer(buf,localOffset,item);
        localOffset = localOffset + myBytesEncoded;
        totalBytesEncoded = totalBytesEncoded + myBytesEncoded;
    });
    return totalBytesEncoded;

}

// given a buffer object, an offset into that buffer, encode the item
// return the number of bytes written
encodeItemIntoBuffer = function(buf,offset,curTerm) {
    if (typeof item == null) {
        return 0;
    } else if (typeof curTerm === "string") {
        // write an atom: 100 + 2 bytes for byte length + string length
        buf[offset] = ATOM_START;
        buf.writeInt16BE(curTerm.length,offset+1);
        buf.write(curTerm,offset+3,curTerm.length);
        return 3 + curTerm.length;
    } else if (typeof curTerm === "number") {
        if (isInt(curTerm)) {
            if (curTerm < SMALL_INT_SIZE) { // max range for a small int
                buf[offset] = SMALL_INT_START;
                buf[offset+1] = curTerm;
                return 2;
            } else {
                buf[offset] = BIG_INT_START;
                buf.writeInt32BE(curTerm,offset+1);
                return 5;
            }
        }
    } else if (util.isArray(curTerm)) {
        // treat like a list
        buf[offset] = LIST_START;
        buf.writeInt32BE(curTerm.length,offset+1);
        var listBytesWritten = encodeItemsIntoBuffer(buf,offset+5,curTerm);
        buf[offset+5+listBytesWritten] = NIL_EXT;
        return 6 + listBytesWritten; // tag + length + nil length
    } else if (curTerm instanceof Tuple) {
        buf[offset] = SMALL_TUPLE_START;
        buf[offset+1] = curTerm.elems.length;
        var tupleBytesWritten = encodeItemsIntoBuffer(buf,offset+2,curTerm.elems);
        return 2 + tupleBytesWritten;
    }
}

/** A representation of a tuple class (which is a container for an array, but allows the code to distinguish them) */
Tuple = function(elements) {
    this.elems = elements;
    
}

erlangLengthFromJavascript = function(items) {
    // we know an erlang buffer always starts with a particular byte
    var binaryLength = 1;
    
    items.forEach(function(curTerm) {
        // there will always be at least one byte indicating the  type of data
        binaryLength = binaryLength + 1;
        
        // determine the type of the object and then add accordingly
        if (typeof curTerm == null) {
            // easy; just skip
        } else if (typeof curTerm === "string") {
            // convert this to an atom
            binaryLength = binaryLength + 2 + curTerm.length; // atom = 2 bytes for length, rest for the atom characters themselves 
        } else if (typeof curTerm === "number") {
            // is it an int or a float?
            if (isInt(curTerm)) {
                // small int?
                if(curTerm < SMALL_INT_SIZE) {
                    binaryLength = binaryLength + 1; // 1 byte to hold number
                } else {
                    binaryLength = binaryLength + 4; // 4 bytes for large numbers
                }
                
            } else {
                // it's a float, which in erlang is a string representation of the float
                // todo support floats
            }
        } else if (util.isArray(curTerm)) {
            binaryLength = binaryLength + 6 + erlangLengthFromJavascript(curTerm); // + 4 for length of list
        } else if (curTerm instanceof Tuple) {
            binaryLength = binaryLength + 1 + erlangLengthFromJavascript(curTerm.elems); // + 1 for the arity of the tuple
        }
    });
    
    return binaryLength;
}

isInt = function(n) {
    return n % 1 == 0;
};

isFloat = function(n) {
    return !isInt(n);
};
